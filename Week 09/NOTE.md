学习笔记

## HTML

1. HTML parse 模块的文件拆分

- 为了方便文件管理,把 html parser 单独拆到文件中
- parser 接收 HTML 文本作为参数,返回一颗 DOM 树

2. 用 FSM 实现 HTML 的分析

- 用 FSM 来实现 HTML 的分析
- 在 HTML 标椎中,已经规定了 HTML 的状态
- Toy-Browser 只挑选其中一部分状态,完成最简版本

3. 解析标签

- 开始标签 结束标签 自封闭标签
- 暂时忽略属性

4. 创建元素

- 除了状态迁移,还要加入业务逻辑
- 在标签结束状态时提交标签 token

5. 处理属性

- 属性值分为单双引号/无引号三种写法,需要多状态处理
- 处理属性的方式跟标签类似
- 出行结束时,我们把属性加到标签`Token`上

6. 用 token 构建 DOM 树

- 从标签构建 DOM 树的基本技巧就是使用 `栈`
- 遇到开始标签,创建元素 -> 入栈,遇到结束标签 -> 出栈
- `自封闭节点`可视为入栈后立即出栈
- 任何元素的父元素是它入栈前的栈顶元素

7. 将文本节点加到 DOM 树

- 文件节点与自封闭标签处理类似
- 多个文本几点需要合并

## CSS

1. 收集 CSS 规则

- 遇到 style 标签时,我们把 CSS 规则保存起来
- 使用`css`的 npm 包来分析 CSS 规则

2. `css` 调用生成 AST 树

- 创建一个元素后立即计算 CSS
- 理论上,当我们分析一个元素时,所有的 CSS 规则已经收集完毕
- 在真是浏览器中,可能遇到卸载 body 的 style 标签,需要重新 CSS 计算的情况,这里我们忽略

3. 获取父元素序列

- 在 `computeCss` 函数中,我们必须知道元素的所有父元素才能判断元素与规则是否匹配
- 我们从上一步骤的 stack 可以获取本元素所有的父元素
- 因为我们首先获取的是 "当前元素",所以我们获得和计算父元素匹配的顺序是从内向外

4. 选择器与元素的匹配

- 选择器从当前元素向外排列
- 复杂选择器拆成针对单个元素的选择器,用循环匹配父元素队列

5. 计算选择器与元素的匹配

- 根据选择器的类型和元素属性,计算是否与当前元素匹配
- 这里仅仅实现了三种基本选择器,还有复合选择器待处理

6. 生成 computed 属性

- 一旦选择器匹配,就应用选择器到元素上,形成 `computedStyle`

7. specificity(特征,转移性,大部分翻译为 `优先级`) 的计算逻辑

- CSS 根据 specificity 和后来优先规则覆盖
- specificity 是个四元组,越左边权重越高
- 一个 CSS 规则的 specificity 根据包含的简单选择器相加而成

## 总结

### HTML 解析

逐字符解析,遇到不同的字符,结合当前的状态,返回新的状态,每个状态下只考虑当前状态可能遇到的字符

### CSS 匹配主要有两点

1. 匹配规则


    - 从右到左,匹配当前元素,然后逐级匹配父元素

2. 权值的计算及比较


    - 优先级高的选择器权值,比较成功则不再继续比较,否则比较下一种选择器
